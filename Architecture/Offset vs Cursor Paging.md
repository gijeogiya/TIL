# Offset vs Cursor 페이징: 서비스 성장에 따른 전략 고찰

서비스 개발을 하다 보면 페이징 구현 전략에 대해 고민하게 된다. 특히 서비스가 성장함에 따라 Offset과 Cursor 페이징 중 어떤 것을 선택할지, 또 어떻게 전환할지에 대한 결정이 필요하다. 이에 대한 내 생각과 경험을 적어보고자 한다.

## Offset vs Cursor: 기본 개념

### Offset 페이징

Offset 페이징은 SQL의 `LIMIT`와 `OFFSET`을 사용하는 방식이다.

```sql
SELECT * FROM posts ORDER BY created_at DESC LIMIT 10 OFFSET 20
```

개인적으로 Offset 방식은 구현이 간단하고 직관적이라 초기 개발 단계에서 선호한다. 하지만 대규모 데이터에서는 성능 저하가 심각해질 수 있다는 점을 경험했다.

### Cursor 페이징

Cursor 페이징은 이전 페이지의 마지막 항목을 기준으로 다음 데이터를 조회한다.

```sql
SELECT * FROM posts WHERE created_at < :last_seen_date ORDER BY created_at DESC LIMIT 10
```

Cursor 방식은 구현이 다소 복잡하지만, 대규모 데이터에서도 일관된 성능을 보여 확장성 면에서 우수하다고 생각한다.

## 서비스 성장 단계별 접근 방식

### 1. 초기 단계: Offset 선택

서비스 초기에는 개발 속도가 중요하다고 본다. 이 때는 Offset 페이징이 적합하다고 판단한다.

- `page=1&size=10`과 같은 직관적인 파라미터로 빠르게 구현 가능
- 관리자 페이지 등에서 임의 페이지 이동이 쉬움
- 초기 데이터 양이 적어 성능 문제가 크지 않음

### 2. 성장 단계: 하이브리드 접근 시도

사용자와 데이터가 늘어나면서 성능 이슈가 발생하기 시작한다. 이 때 나는 하이브리드 접근을 시도해 보는 것이 좋다고 생각한다.

- Cursor와 Offset을 동시 지원하는 API 설계
  ```
  GET /api/v1/posts?page=2&size=10  // Offset
  GET /api/v1/posts?cursor=xyz123   // Cursor
  ```
- 성능 모니터링 강화
- 클라이언트를 위한 SDK 제공 고려

### 3. 대규모 단계: Cursor로의 전환

데이터가 수백만 건을 넘어가면 Cursor 페이징으로의 전환이 불가피하다고 본다.

- B-Tree 인덱스 활용으로 성능 최적화
- 실시간 데이터 변경에 더 강건한 페이징 제공
- 새 버전 API에서는 Cursor만 지원하는 것이 좋다고 판단

## 서버 세션을 활용한 Cursor 관리(내가 고민해본 설계이다.)

Cursor 토큰 관리의 부담을 줄이기 위해 서버 세션을 활용하는 방법을 제안하고 싶다. 작동 방식은 다음과 같다:

1. 클라이언트의 초기 요청 시 서버에서 세션 ID 생성
2. 서버는 세션 ID와 Cursor 정보를 저장
3. 클라이언트는 세션 ID, 페이지 크기, 페이지 번호만 전송

API 요청 예시(세션ID는 보통 쿠키로 주고 받지만, 이 경우 보기 쉽도록 예시를 구성했다.)
```
GET /api/v1/posts?session_id=abcd1234&page_size=10&page=2
```

4. 서버는 세션 ID로 Cursor 정보를 조회하고 해당 페이지 데이터 반환
5. 서버는 새로운 Cursor 정보를 세션에 업데이트

이 방식의 장단점을 고려해봤다:

장점:
- 클라이언트 개발자의 Cursor 관리 부담 감소
- 서버에서 중앙 관리로 일관성 유지 용이
- 클라이언트는 익숙한 페이지 번호 방식 유지

단점:
- 서버 리소스 사용 증가 및 세션 관리 복잡성 증가
- 세션 타임아웃 관리 필요
- 분산 환경에서 세션 동기화 주의 필요

## 결론

페이징 전략은 서비스 성장에 따라 진화해야 한다고 생각한다. 내 경험상 초기에는 Offset으로 시작하고, 점진적으로 Cursor로 전환하는 것이 이상적이다. 서버 세션을 활용한 Cursor 관리는 전환 과정의 중간 단계로 고려해볼 만하다.

하지만 이는 정답이 아니며, 각 서비스의 특성과 요구사항에 따라 다르게 접근해야 한다. 기술적 선택뿐만 아니라 비즈니스 요구사항, 개발자와 사용자 경험을 모두 고려한 균형 잡힌 접근이 필요하다고 본다.
