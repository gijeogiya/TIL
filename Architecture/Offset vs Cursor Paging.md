# Offset vs Cursor 페이징: 서비스 성장에 따른 최적 전략

서비스가 성장함에 따라 페이징 구현 전략은 중요한 고려사항이 된다. Offset과 Cursor 페이징 각각의 특성을 이해하고, 서비스의 단계에 맞는 적절한 선택이 필요하다. 이 글에서는 두 방식의 차이점과 서비스 성장에 따른 최적의 페이징 전략을 제시한다.

## Offset vs Cursor: 기본 개념

### Offset 페이징

Offset 페이징은 SQL의 `LIMIT`와 `OFFSET` 키워드를 사용하여 구현한다.

```sql
SELECT * FROM posts ORDER BY created_at DESC LIMIT 10 OFFSET 20
```

장점은 구현이 간단하고 직관적이라는 것이다. 단점으로는 데이터가 많아질수록 성능이 저하된다는 점이 있다.

### Cursor 페이징

Cursor 페이징은 이전 페이지의 마지막 항목을 기준으로 다음 페이지를 조회한다.

```sql
SELECT * FROM posts WHERE created_at < :last_seen_date ORDER BY created_at DESC LIMIT 10
```

장점은 대규모 데이터셋에서도 일관된 성능을 보인다는 것이다. 단점으로는 구현이 복잡하고, 임의의 페이지로 이동이 어렵다는 점이 있다.

## 서비스 성장 단계별 전략

### 1. 초기 단계: Offset 우선

서비스 초기에는 개발 속도와 사용 편의성이 중요하다. 이 단계에서는 Offset 페이징이 적합하다.

- 개발 생산성: `page=1&size=10`과 같은 직관적인 파라미터 사용이 가능하다.
- 유연한 탐색: 관리자 페이지 등에서 임의의 페이지로 쉽게 이동할 수 있다.
- 성능 이슈 미미: 데이터가 적을 때는 Offset의 성능 저하가 크지 않다.

### 2. 성장 단계: 하이브리드 접근

사용자가 증가하고 데이터가 늘어나면서 성능 이슈가 발생하기 시작한다. 이 때는 하이브리드 접근이 필요하다.

- 점진적 도입: Cursor와 Offset을 동시에 지원하는 API를 설계한다.
  ```
  GET /api/v1/posts?page=2&size=10  // Offset
  GET /api/v1/posts?cursor=xyz123   // Cursor
  ```
- 모니터링 강화: 페이징 관련 성능 지표를 수집하고 분석한다.
- 클라이언트 SDK 제공: Cursor 사용을 위한 라이브러리를 배포한다.

### 3. 대규모 단계: Cursor 전환

데이터가 수백만 건을 넘어가면 Cursor 페이징으로의 전환이 필요하다.

- 성능 최적화: B-Tree 인덱스를 활용한 빠른 데이터 접근이 가능하다.
- 실시간 데이터 처리: 데이터 추가/삭제에 강건한 페이징을 제공한다.
- API 버저닝: 새로운 버전의 API에서 Cursor만 지원하도록 한다.

## 서버 세션을 활용한 Cursor 토큰 관리

Cursor 토큰을 클라이언트에서 관리하는 것이 부담스러운 경우, 서버 세션을 활용하는 방법도 고려할 수 있다. 이 방식의 구현과 작동 원리는 다음과 같다:

1. 클라이언트가 초기 페이지 요청을 보내면 서버에서 세션 ID를 생성한다.
2. 서버는 이 세션 ID와 함께 Cursor 정보를 서버 측에 저장한다.
3. 클라이언트는 세션 ID, 페이지 크기, 그리고 요청하는 페이지 번호를 함께 전송한다.

API 요청 예시:
```
GET /api/v1/posts?session_id=abcd1234&page_size=10&page=2
```

4. 서버는 세션 ID를 통해 저장된 Cursor 정보를 조회하고, 요청된 페이지 번호와 크기에 맞는 데이터를 반환한다.
5. 서버는 반환된 데이터에 해당하는 새로운 Cursor 정보를 세션에 업데이트한다.

이 방식의 장단점은 다음과 같다:

장점:
- 클라이언트 개발자들의 Cursor 관리 부담을 줄일 수 있다.
- 서버에서 Cursor 정보를 중앙 관리할 수 있어 일관성 유지가 용이하다.
- 클라이언트는 여전히 익숙한 페이지 번호 방식으로 데이터를 요청할 수 있다.

단점:
- 서버 리소스를 더 사용하게 되며, 세션 관리에 따른 추가적인 복잡성이 발생한다.
- 세션 타임아웃 관리가 필요하며, 이에 따른 사용자 경험 설계가 중요하다.
- 분산 환경에서는 세션 정보의 동기화에 주의를 기울여야 한다.

## 결론

페이징 전략은 서비스의 성장과 함께 진화해야 한다. 초기에는 개발 속도와 사용 편의성을 위해 Offset을 선택하고, 성장함에 따라 점진적으로 Cursor로 전환하는 것이 이상적이다. 서버 세션을 활용한 Cursor 관리는 클라이언트의 부담을 줄이면서도 Cursor 페이징의 이점을 취할 수 있는 중간 단계로 고려할 수 있다.

성공적인 페이징 전략은 단순히 기술적 선택의 문제가 아니다. 비즈니스 요구사항, 개발자 경험, 그리고 사용자 경험을 모두 고려한 균형 잡힌 접근이 필요하다. 서비스의 규모와 특성에 맞는 최적의 페이징 전략을 선택하고, 필요에 따라 유연하게 조정해 나가는 것이 중요하다.