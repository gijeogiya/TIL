# Offset vs Cursor Pagination
> 대규모 시스템에서의 데이터 조회 시스템 설계

서비스 개발을 하다 보면 페이징 구현 전략에 대해 고민하게 됩니다. 백엔드 개발을 하시다보면 Offset과 Cursor 페이징 중 어떤 것을 선택할지 고민하게 됩니다.     
*참고로 여기서 말하는 Cursor는 AI툴도 아니고, SQL에서의 cursor도 아닙니다. 테이블 Index 장부에서의 책갈피 정도로 이해하시면 될 것 같습니다.     

## Offset vs Cursor: 기본 개념과 설계

### Offset 페이징

Offset 페이징은 SQL의 `LIMIT`와 `OFFSET`을 사용하는 방식입니다.

```sql
SELECT * FROM posts ORDER BY created_at DESC LIMIT 10 OFFSET 20
```

개인적으로 Offset 방식은 구현이 간단하고 직관적이라 초기 개발 단계에서 선호했습니다. 하지만 데이터의 규모가 점차 커지면서 성능 저하가 심각해진다는 것을 경험했습니다.

### Cursor 페이징

Cursor 페이징은 이전 페이지의 마지막 항목을 기준으로 다음 데이터를 조회합니다.

```sql
SELECT * FROM posts WHERE created_at < :last_seen_date ORDER BY created_at DESC LIMIT 10
```

Cursor 방식은 구현이 다소 복잡하지만, 대규모 데이터에서도 일관된 성능을 보여 확장성 면에서 우수합니다.

## 서비스 성장 단계별 내 접근 방식

### 1. 초기 단계: Offset 선택

서비스 초기에는 개발 속도가 중요합니다. 이 때는 Offset 페이징이 적합하다고 판단 할 수 있습니다.

- `page=1&size=10`과 같은 직관적인 파라미터로 빠르게 구현 가능
- 클라이언트(제휴 서비스)의 진입 장벽을 낮춰 대규모 서비스로의 도약에 유리
- 초기 데이터 양이 적어 성능 문제가 크지 않음

### 2. 서비스의 성장 단계: 조회 방식의 전환과 API 변경 리스크

사용자와 데이터가 늘어나면 성능 이슈가 발생하게 됩니다. Cursor 페이징으로의 전환을 고려하겠지만, API 변경에 따른 부담이 클 수 있습니다.

- 기존 클라이언트 코드 수정 필요
- API 문서 업데이트 및 재배포
- 클라이언트 개발팀과의 조율 필요
- API의 무상태성 훼손

이러한 고민 끝에 API 인터페이스를 크게 변경하지 않으면서 Cursor의 이점을 취할 수 있는 방법을 모색했습니다.

### 3. 해결책: 서버 세션을 활용한 Cursor 관리

API 변경의 부담을 최소화하면서 Cursor 페이징의 이점을 취하기 위해 서버 세션을 활용하는 방법을 고안했습니다.

1. 클라이언트의 초기 요청 시 서버에서 세션 ID 생성
2. 서버는 세션 ID와 Cursor 정보를 저장
3. 클라이언트는 기존과 유사하게 세션 ID, 페이지 크기, 페이지 번호만 전송 (사실 세션 ID도 쿠키로 내려주면 클라이언트 개발은 불필요하긴하다...)

API 요청 예시 (보통의 경우 세션ID는 쿠키로서 주고받지만 알아보기 쉽게 예시를 만들어 봤다.)
```
GET /api/v1/posts?session_id=abcd1234&page_size=10&page=2
```

4. 서버는 세션 ID로 Cursor 정보를 조회하고 해당 페이지 데이터 반환
5. 서버는 새로운 Cursor 정보를 세션에 업데이트

#### 이 방식의 장단점

#### 장점
- 클라이언트 API 사용 방식을 유지(API의 무상태성 유지? 혹은 달성)
- 서버 내부적으로 Cursor 페이징의 성능 개선
- 점진적 전환 가능

#### 단점
- 무한 스크롤과 같은 방식의 UI 변경 필요
- 서버 리소스 사용 증가 및 세션 관리 복잡성 증가
- 분산 환경에서 세션 동기화 이슈

## 결론

페이징 전략은 서비스 성장에 따라 진화해야 한다고 생각합니다. 경험상 초기에는 Offset으로 시작하고, 성능 이슈가 발생하면 서버 세션을 활용한 Cursor 관리 방식을 도입하는 것이 API 변경의 부담을 줄이면서 성능을 개선할 수 있는 좋은 방법이라고 생각합니다.
