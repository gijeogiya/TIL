# Offset vs Cursor Pagination
## 서비스 성장에 따른 대규모 시스템 설계
서비스 개발을 하다 보면 페이징 구현 전략에 대해 고민하게 된다. 특히 서비스가 성장함에 따라 Offset과 Cursor 페이징 중 어떤 것을 선택할지, 또 어떻게 전환할지에 대한 결정이 필요하다.

## Offset vs Cursor: 기본 개념과 설계 대한 고민

### Offset 페이징

Offset 페이징은 SQL의 `LIMIT`와 `OFFSET`을 사용하는 방식이다.

```sql
SELECT * FROM posts ORDER BY created_at DESC LIMIT 10 OFFSET 20
```

개인적으로 Offset 방식은 구현이 간단하고 직관적이라 초기 개발 단계에서 선호했고 레거시 코드는 그러하게 구현되어 있었다. 하지만 대규모 데이터에서는 성능 저하가 심각해진다는 점을 경험했다.

### Cursor 페이징

Cursor 페이징은 이전 페이지의 마지막 항목을 기준으로 다음 데이터를 조회한다.

```sql
SELECT * FROM posts WHERE created_at < :last_seen_date ORDER BY created_at DESC LIMIT 10
```

Cursor 방식은 구현이 다소 복잡하지만, 대규모 데이터에서도 일관된 성능을 보여 확장성 면에서 우수하다고 생각한다.

## 서비스 성장 단계별 내 접근 방식

### 1. 초기 단계: Offset 선택

서비스 초기에는 개발 속도가 중요하다고 본다. 이 때는 Offset 페이징이 적합하다고 판단한다.

- `page=1&size=10`과 같은 직관적인 파라미터로 빠르게 구현 가능
- 관리자 페이지 등에서 임의 페이지 이동이 쉬움
- 초기 데이터 양이 적어 성능 문제가 크지 않음

### 2. 성장 단계: 전환 고민과 API 변경 리스크

사용자와 데이터가 늘어나면서 성능 이슈가 발생하기 시작했다. Cursor 페이징으로의 전환을 고려했지만, API 변경에 따른 부담이 컸다.

- 기존 클라이언트 코드 수정 필요
- API 문서 업데이트 및 재배포
- 클라이언트 개발팀과의 조율 필요
- API의 무상태성 훼손

이러한 고민 끝에 API 인터페이스를 크게 변경하지 않으면서 Cursor의 이점을 취할 수 있는 방법을 모색하게 되었다.

### 3. 해결책: 서버 세션을 활용한 Cursor 관리

API 변경의 부담을 최소화하면서 Cursor 페이징의 이점을 취하기 위해 서버 세션을 활용하는 방법을 고안했다.

1. 클라이언트의 초기 요청 시 서버에서 세션 ID 생성
2. 서버는 세션 ID와 Cursor 정보를 저장
3. 클라이언트는 기존과 유사하게 세션 ID, 페이지 크기, 페이지 번호만 전송 (사실 세션 ID도 쿠키로 내려주면 클라이언트 개발을 불필요하긴하다...)

API 요청 예시 (보통의 경우 세션ID는 쿠키로서 주고받지만 알아보기 쉽게 예시를 만들어 봤다.)
```
GET /api/v1/posts?session_id=abcd1234&page_size=10&page=2
```

4. 서버는 세션 ID로 Cursor 정보를 조회하고 해당 페이지 데이터 반환
5. 서버는 새로운 Cursor 정보를 세션에 업데이트

#### 이 방식의 장단점

#### 장점
- 클라이언트 API 사용 방식을 유지(API의 무상태성 유지? 혹은 달성)
- 서버 내부적으로 Cursor 페이징의 성능 개선
- 점진적 전환 가능

#### 단점
- 서버 리소스 사용 증가 및 세션 관리 복잡성 증가
- 분산 환경에서 세션 동기화 이슈

## 결론

페이징 전략은 서비스 성장에 따라 진화해야 한다고 생각한다. 내 경험상 초기에는 Offset으로 시작하고, 성능 이슈가 발생하면 서버 세션을 활용한 Cursor 관리 방식을 도입하는 것이 API 변경의 부담을 줄이면서 성능을 개선할 수 있는 좋은 방법이라고 본다.

하지만 이는 정답은 아니며, 각 서비스의 특성과 요구사항에 따라 다르게 접근해야 한다. 기술적 선택뿐만 아니라 비즈니스 요구사항, 개발자와 사용자 경험을 모두 고려한 균형 잡힌 접근이 필요하다고 본다.
